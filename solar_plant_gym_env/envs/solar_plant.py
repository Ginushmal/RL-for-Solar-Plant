from enum import Enum

import pandas as pd
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import matplotlib
matplotlib.use('TkAgg')  # Replace 'TkAgg' with 'Qt5Agg', 'MacOSX', etc., depending on your environment
import matplotlib.pyplot as plt




class SolarPlant(gym.Env):
    metadata = {"render_modes": ["ansi", "human"], "render_fps": 4}
    
    def __init__(self, render_mode=None,epi_days= 1, out_power_const = 5000 , battry_cap = 86000 , battrry_charge_rate = 22000 , max_solor_power = 30000 , time_step = 15,data_file="Vydexa_lanka_data_cleaned.csv"):    

        self.out_power_const = out_power_const
        self.battry_cap = battry_cap
        self.battrry_charge_rate = battrry_charge_rate
        self.max_solor_power = max_solor_power
        self.time_step = time_step 
        self.epi_days = epi_days
        self.data_file = data_file
        
        self.info_df = pd.DataFrame(columns=["current_time","current_power","battery_charge","total_output_power","action","reward"])
        self.fig, self.ax = None, None  # Initialize figure and axes for persistent plotting
        
        # observations are 
        # - the current power generated by the solar plant 
        # - the current battery charge 
        # - the current time of the day
        # (each values are normalized to be between 0 and 1)
        self.observation_space = spaces.Box(low = 0, high = 1, shape = (3,))
        
        # actions are 
        #   0 - **Charge the battery** (store energy in the battery)
        #   1 - **Discharge the battery** (release energy from the battery).
        #   2 - **Do nothing** (leave the system unchanged).
        self.action_space = spaces.Discrete(3)
        
        assert render_mode is None or render_mode in self.metadata["render_modes"]
        self.render_mode = render_mode
        
    def normalize_time_from_datetime(self,datetime_value):
        datetime_value = pd.to_datetime(datetime_value)
        # Extract the time part
        total_seconds = (
            datetime_value.hour * 3600
            + datetime_value.minute * 60
            + datetime_value.second
        )
        # Normalize the time
        normalized_time = total_seconds / 86400  # Total seconds in a day
        return normalized_time
        
    def get_observation(self):
        return np.array([self.current_power/self.max_solor_power , self.current_battery_charge/self.battry_cap , self.current_time])
    
    def reset(self , seed= None ,options=None):
        super().reset(seed= seed)
        
        plant_df = pd.read_csv(self.data_file)
        num_of_dates = plant_df["DATE"].nunique()
        
        
        # # Get te date as a random date from 0 - num_of_dates
        # episodes_date = np.random.randint(0,num_of_dates)
        
        # self.data_for_epi_date = plant_df[plant_df["DATE"] == episodes_date].reset_index(drop=True)
        # Get multiple random dates as an array of integers
        random_dates = np.random.randint(0, num_of_dates, size=self.epi_days)  # Replace 10 with the number of random dates you want

        # Filter the dataframe where the DATE is in the list of random dates
        self.data_for_epi_date = plant_df[plant_df["DATE"].isin(random_dates)].reset_index(drop=True)

        self.df_index = 0
        
        self.current_power = self.data_for_epi_date.iloc[self.df_index]["DC_POWER"]
        self.current_battery_charge = np.random.randint(0,self.battry_cap)
        self.current_time = self.normalize_time_from_datetime(self.data_for_epi_date.iloc[self.df_index]["TIME"])
        
        observation = self.get_observation()
        info = {"info_df" : self.info_df}
        
        # reset the info_df 
        self.info_df = pd.DataFrame(columns=["current_time","current_power","battery_charge","total_output_power","action","reward"])
        
        
        
        return observation, info
    
    def step(self, action):
        """
        Execute an action and return the updated state, reward, done flag, and optional info.
        """
        # Initialize reward
        reward = 0

        # Get solar power for the current time step
        solar_power = self.current_power
        
        charge_power = 0
        discharge_power = 0 
        
        # Handle actions
        if action == 0:  # Charge the battery
            effective_charged_energy = min(self.battrry_charge_rate, solar_power)*self.time_step/60
            charge_power = min(
                effective_charged_energy,
                self.battry_cap - self.current_battery_charge
            )
            self.current_battery_charge += charge_power

        elif action == 1:  # Discharge the battery
            effective_discharge_energy = min(self.battrry_charge_rate, max(0, self.out_power_const - solar_power))*self.time_step/60
            discharge_power = min(
                effective_discharge_energy,
                self.current_battery_charge
            )
            self.current_battery_charge -= discharge_power
        else:  # Do nothing
            discharge_power = 0  # No discharge
            charge_power = 0  # No charge
        
        # Calculate total output power (solar + discharge - charge)
        self.total_output_power = solar_power + (discharge_power - charge_power)/(self.time_step/60)

        # Calculate reward based on output stability
        power_deviation = (self.total_output_power - self.out_power_const)
        
        if power_deviation < 0:        
            reward -= (power_deviation**2) * 0.00002  # Penalize deviation
        else:
            reward -= power_deviation * 0.0001  # Penalize deviation
        
        # Penalize battery over-discharge or overcharge
        if self.current_battery_charge < self.battry_cap * 0.2:
            reward -= 1  
        elif self.current_battery_charge > self.battry_cap * 0.8:
            reward -= 1
            
        if power_deviation < 1000:  # Set a tolerance for "close enough"
            reward += 200  # Reward for staying close to target output power

        
        if self.info_df.empty:
            # If the DataFrame is empty, initialize it with the new row
            self.info_df = pd.DataFrame([{
                "current_time": self.current_time,
                "current_power": self.current_power,
                "battery_charge": self.current_battery_charge,
                "total_output_power": self.total_output_power,
                "action": action,
                "reward": reward
            }])
        else:
            # Otherwise, concatenate the new row to the existing DataFrame
            new_row = pd.DataFrame([{
                "current_time": self.current_time,
                "current_power": self.current_power,
                "battery_charge": self.current_battery_charge,
                "total_output_power": self.total_output_power,
                "action": action,
                "reward": reward
            }])
            self.info_df = pd.concat([self.info_df, new_row], ignore_index=True)


        
        # Update time and data for the next step
        self.df_index += 1
        done = self.df_index >= len(self.data_for_epi_date) - 1

        if not done:
            self.current_power = self.data_for_epi_date.iloc[self.df_index]["DC_POWER"]
            self.current_time = self.normalize_time_from_datetime(
                self.data_for_epi_date.iloc[self.df_index]["TIME"]
            )
        else:
            self.current_power = 0
            self.current_time = 0

        # Prepare observation
        observation = self.get_observation()
        
        if self.render_mode == "human":
            self._render_frame()

        # Return observation, reward, done flag, and additional info
        return observation, reward, done, False , {}

    def render(self, mode="ansi"):
        if mode == "ansi":
            return f"Current power: {self.current_power}, Current battery charge: {self.current_battery_charge}, Current time: {self.current_time}, Total output power: {self.total_output_power}"
        else:
            super().render(mode=mode)
    
    def _render_frame(self):
        # Initialize the plot only once
        if self.fig is None or self.ax is None:
            plt.ion()  # Turn on interactive mode
            self.fig, self.ax = plt.subplots(figsize=(10, 6))
            self.ax.set_title('Power, Battery Charge, and Output vs Time', fontsize=14)
            self.ax.set_xlabel('Current Time', fontsize=12)
            self.ax.set_ylabel('Values', fontsize=12)
            self.ax.grid(True)
            plt.show(block=False)  # Ensure the plot is displayed

        # Clear previous data
        self.ax.clear()

        # Ensure there's data to plot
        if self.info_df.empty or 'current_time' not in self.info_df:
            print("No data available to render.")
            return

        # Handle identical min and max xlim
        if self.info_df['current_time'].nunique() <= 1:
            self.ax.set_xlim(self.info_df['current_time'].min() - 0.1, self.info_df['current_time'].max() + 0.1)
        else:
            self.ax.set_xlim(self.info_df['current_time'].min(), self.info_df['current_time'].max())

        # Plot the data
        self.ax.plot(self.info_df['current_time'], self.info_df['current_power'], label='Current Power', color='b', marker='o')
        self.ax.plot(self.info_df['current_time'], self.info_df['battery_charge'], label='Battery Charge', color='g', marker='x')
        self.ax.plot(self.info_df['current_time'], self.info_df['total_output_power'], label='Total Output Power', color='r', marker='s')

        # Add legend and refresh the plot
        self.ax.legend()
        self.fig.canvas.draw()
        self.fig.canvas.flush_events()

    def close(self):
        if self.fig:
            plt.ioff()  # Turn off interactive mode
            plt.close(self.fig)  # Close the persistent plot window
            self.fig, self.ax = None, None